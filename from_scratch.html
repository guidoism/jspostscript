<style type="text/css" media="screen">
 #editor { 
     position: absolute;
     top: 600;
     right: 0;
     bottom: 0;
     left: 0;
 }
</style>

<canvas id="canvas" width="700" height="500"></canvas>
<div id="editor">    5 200 moveto
    (The fox went to find the fjord.) show
    newpath
    1  1 moveto
    91  1 lineto
    91 91 lineto
    1 91 lineto
    1  1 lineto
    stroke</div>

<script src="https://code.jquery.com/jquery-3.3.1.slim.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/voca/1.4.0/voca.min.js"></script>
<script src="ace-builds/src-noconflict/ace.js" type="text/javascript" charset="utf-8"></script>
<script src="https://unpkg.com/ohm-js@0.13.1/dist/ohm.min.js"></script>

<script>
 var canvas = document.getElementById('canvas');
 var c = canvas.getContext('2d');

 if (window.devicePixelRatio) {
     var canvasWidth = $(canvas).attr('width');
     var canvasHeight = $(canvas).attr('height');
     var canvasCssWidth = canvasWidth;
     var canvasCssHeight = canvasHeight;
     $(canvas).attr('width', canvasWidth * window.devicePixelRatio);
     $(canvas).attr('height', canvasHeight * window.devicePixelRatio);
     $(canvas).css('width', canvasCssWidth);
     $(canvas).css('height', canvasCssHeight);
     c.scale(window.devicePixelRatio, window.devicePixelRatio);
 }

 let parser = ohm.grammar(`
Postscript {
  Exp             = Pexp+
  Pexp            = word | operator | number | string
  word            = "/" letter+
  operator        = letter+
  number          = digit+
  string          = "(" not_right_paren+ ")"
  not_right_paren = escaped_paren | ~")" any
  escaped_paren   = "\\\\" ")"
}
 `);

 $( document ).ready(function() {
     c.font = '48px Minion Pro';

     let _x = 0;
     let _y = 0;
     let ostack = [];
     let pop = function() { return ostack.pop() };
     let code = {
	 // Canvas doesn't provide the ability to draw text along a
	 // curve so we need to implement basic text another way and
	 // just not support curved text yet.
	 show: () => c.fillText(pop(), _x, _y),
	 moveto: () => { _y = pop(); _x = pop(); c.moveTo(_x, _y) },
	 newpath: () => c.beginPath(),
	 stroke: () => c.stroke(),
	 lineto: () => c.lineTo(pop(), pop()),
     };

     function call(e) {
	 if (code[e.sourceString])
	     code[e.sourceString](_x, _y)
	 else
	     console.log(`Operator ${e.sourceString} not defined`)
     }
     
     let semantics = parser.createSemantics()
     semantics.addOperation('eval', {
	 Exp: e => e.eval(),
	 word: (left, right) => ostack.push(left.eval() + right.eval()),
	 operator: e => call(e),
	 number: e => ostack.push(e.sourceString),
	 string: (left, e, right) => ostack.push(e.sourceString),
     })
     
     var editor = ace.edit("editor");
     editor.setTheme("ace/theme/solarized_dark");
     editor.session.setMode("ace/mode/forth");
     editor.commands.addCommand({
	 name: 'Run',
	 bindKey: {win: 'Ctrl-R',  mac: 'Ctrl-R'},
	 exec: function(editor) {
	     var lines = editor.session.getDocument().getAllLines();
	     lines.map(s => semantics(parser.match(s)).eval())
	 },
	 readOnly: true
     });

 });
</script>

<script>
